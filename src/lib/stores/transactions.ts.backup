// Nueva versión de transactions.ts sin referencias a Firebase
import { writable, get } from 'svelte/store';

import { 
    cacheTransactions, 
    getCachedTransactions, 
    updateCachedTransaction,
    deleteCachedTransaction,
    getLastCachedDocId
} from '../services/idb-service'; // Servicio de caché con IndexedDB

// Importamos el nuevo servicio para cargar datos locales
import { loadLocalTransactions } from '../services/local-data-service';

// Definición de tipos
export type TransactionType = 'ingreso' | 'egreso';

export interface Transaction {
    id: string;
    description: string;  // Pagado A
    amount: number;
    date: string;
    type: TransactionType;
    category?: string;    // Mantenido para compatibilidad con datos antiguos
    // Campos adicionales (opcionales)
    location?: string;    // Opciones (Casa o Match Home)
    cuenta?: string;      // Cuenta principal
    subcuenta?: string;   // Subcuenta específica
    paymentMethod?: string;  // Pagado con
    invoice?: string;     // Referencia
    tags?: string;        // Etiquetas
    notes?: string;       // Notas adicionales
    businessPurpose?: string;  // Pagado por
    merchant?: string;    // Para compatibilidad con datos antiguos
    receiptNumber?: string; // Para compatibilidad con datos antiguos
}

// Define extended type that includes formattedAmount
interface TransactionInput extends Partial<Transaction> {
    formattedAmount?: string | number;
    [key: string]: any; // Allow any other properties that might exist in the JSON
}

// Función para reiniciar todas las transacciones y volver a cargar los datos
export async function resetAllTransactionsAndReload(): Promise<void> {
    try {
        // Restablecer el store a un array vacío
        transactions.set([]);
        
        // Resetear los estados
        isInitialDataLoaded.set(false);
        isLoadingMore.set(false);
        hasMoreData.set(true);
        
        // Volver a cargar la primera página
        await loadFirstPage();
        
        console.log('[transactions.ts] Datos restablecidos y recargados correctamente');
    } catch (error) {
        console.error('[transactions.ts] Error al reiniciar y recargar datos:', error);
        throw error; // Propagar el error
    }
}

// Configuración para la paginación
const PAGE_SIZE = 50; // Número de transacciones por página
export const isLoadingMore = writable<boolean>(false);
export const hasMoreData = writable<boolean>(true);
export const isInitialDataLoaded = writable<boolean>(false);

// Store principal de transacciones
export const transactions = writable<Transaction[]>([]);

// Función para actualizar una transacción existente
export async function updateTransaction(transactionData: Transaction): Promise<void> {
    if (!transactionData.id) {
        console.error('[transactions.ts] Error: Se intentó actualizar una transacción sin ID.');
        throw new Error('No se puede actualizar una transacción sin ID.');
    }
    try {
        // Solo actualizamos en la caché
        await updateCachedTransaction(transactionData);
        
        // Actualización optimista del store para mejor UX
        transactions.update(items => {
            const updatedItems = items.map(item => 
                item.id === transactionData.id ? transactionData : item
            );
            
            // Re-ordenar después de actualizar (importante si cambió la fecha)
            updatedItems.sort((a, b) => {
                const dateA = new Date(a.date).getTime();
                const dateB = new Date(b.date).getTime();
                return dateB - dateA;
            });
            
            return updatedItems;
        });
        
        if (import.meta.env.DEV) {
            console.log('[transactions.ts] Transacción actualizada localmente con ID: ', transactionData.id);
        }
    } catch (error) {
        console.error('[transactions.ts] Error al actualizar la transacción localmente: ', error);
        throw error; // Propagar el error para que el componente lo maneje
    }
}

// Función para añadir una nueva transacción
export async function addTransaction(transactionData: Omit<Transaction, 'id'>): Promise<string | null> {
    try {
        // Normalizar el tipo de transacción para asegurar consistencia
        const normalizedType = normalizeTransactionType(transactionData.type);
        
        // Generamos un ID local único
        const id = `local-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
        
        // Preparamos el objeto a guardar
        const completeTransaction: Transaction = {
            ...transactionData as any,
            id,
            type: normalizedType
        };

        // Actualizar la caché con la nueva transacción
        await updateCachedTransaction(completeTransaction);
        
        // Actualización optimista del store (para mejor UX)
        transactions.update(items => {
            // Agregar la nueva transacción al inicio (es la más reciente)
            const updated = [completeTransaction, ...items];
            
            // Re-ordenar por fecha descendente para mantener consistencia
            updated.sort((a, b) => {
                const dateA = new Date(a.date).getTime();
                const dateB = new Date(b.date).getTime();
                return dateB - dateA;
            });
            
            return updated;
        });
        
        if (import.meta.env.DEV) {
            console.log('Transacción guardada localmente con ID: ', id);
        }
        
        return id;
    } catch (error) {
        console.error('Error al añadir la transacción localmente: ', error);
        return null;
    }
}

// Función para eliminar una transacción
export async function removeTransaction(id: string): Promise<void> {
    try {
        // Eliminar de la caché
        await deleteCachedTransaction(id);
        
        // Actualización optimista para mejor UX
        transactions.update(items => items.filter(item => item.id !== id));
        
        if (import.meta.env.DEV) {
            console.log('Transacción eliminada localmente con ID: ', id);
        }
    } catch (error) {
        console.error('Error al eliminar la transacción localmente: ', error);
        throw error; // Propagar el error para que el componente lo maneje
    }
}

// Función para normalizar el tipo de transacción
function normalizeTransactionType(type: string): TransactionType {
    if (!type) return 'egreso'; // Default to egreso if undefined
    
    const lowerType = type.toLowerCase();
    if (lowerType === 'ingreso') return 'ingreso';
    if (lowerType === 'egreso') return 'egreso';
    
    // Handling for legacy data with different names
    if (lowerType === 'gasto') return 'egreso';
    if (lowerType === 'income') return 'ingreso';
    if (lowerType === 'expense') return 'egreso';
    if (lowerType === 'ingresso') return 'ingreso';
    if (lowerType === 'egresso') return 'egreso';
    
    // For data with capitalized first letter
    if (type === 'Ingreso') return 'ingreso';
    if (type === 'Egreso') return 'egreso';
    
    // Default
    return 'egreso';
}

// Función para cargar la primera página de transacciones
export async function loadFirstPage(): Promise<void> {
    if (get(isLoadingMore)) return;
    
    isLoadingMore.set(true);
    hasMoreData.set(true);
    isInitialDataLoaded.set(false);
    
    try {
        // Cargar directamente desde el archivo local db.json
        const localTransactions = await loadLocalTransactions();
        
        if (localTransactions && localTransactions.length > 0) {
            // Guardar en caché para futuras cargas
            await cacheTransactions(localTransactions);
            
            // Configurar el store con los datos locales
            transactions.set(localTransactions);
            
            // Ya que cargamos todos los datos locales de una vez, no hay más páginas
            hasMoreData.set(false);
            
            if (import.meta.env.DEV) {
                console.log(`[transactions.ts] Cargados ${localTransactions.length} transacciones desde archivo local`);
            }
        } else {
            console.warn('[transactions.ts] No se pudieron cargar datos locales');
            transactions.set([]);
        }
    } catch (error) {
        console.error('[transactions.ts] Error al cargar datos locales:', error);
    } finally {
        isLoadingMore.set(false);
        isInitialDataLoaded.set(true);
    }
}

// Función para cargar más transacciones (siguiente página)
export async function loadMoreTransactions(): Promise<void> {
    hasMoreData.set(false);
    
    if (import.meta.env.DEV) {
        console.log('[transactions.ts] No hay paginación con datos locales - todos los datos ya están cargados');
    }
    return;
}

// Inicialización
if (import.meta.env.DEV) {
    console.log('[transactions.ts] Usando datos locales normalizados');
}
