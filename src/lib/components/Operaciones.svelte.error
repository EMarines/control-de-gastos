<script lang="ts">
    import { onMount } from 'svelte';
    import { 
        transactions, 
        type Transaction, 
        removeTransaction, 
        updateTransaction, 
        addTransaction,
        loadFirstPage,
        loadMoreTransactions, 
        isLoadingMore,
        hasMoreData,
        isInitialDataLoaded 
    } from '../stores/transactions'; // Importar el store, tipo y funciones de paginación
    import ActionButton from './ActionButton.svelte';
    import { forceRefreshData, refreshing } from '../services/data-refresh';
    import IncomeModal from './IncomeModal.svelte'; // Asegúrate que la ruta sea correcta
    import ExpenseModal from './ExpenseModal.svelte'; // Asegúrate que la ruta sea correcta
    
    import { formatCurrency } from '../util/formatters'; // Importar la función de formato
    
    type Operacion = Transaction; 
    
    let operaciones: Operacion[] = [];
    let operacionesFiltradas: Operacion[] = [];
    let datosCargadosInicialmente: boolean = false; // Para saber si ya procesamos los datos del store una vez
    
    // Filtros
    let filtroTipo: string = 'todos'; // 'todos', 'ingreso', 'egreso'
    let filtroCuenta: string = 'todas'; // Cambiado de filtroCategoria a filtroCuenta
    let filtroUbicacion: string = 'todas';
    let filtroBusqueda: string = '';
    let filtroFechaDesde: string = '';
    let filtroFechaHasta: string = '';
    
    // Ordenación
    let ordenPor: string = 'fecha'; // 'fecha', 'monto', 'descripcion'
    let ordenDireccion: 'asc' | 'desc' = 'desc';
    
    // Cuentas únicas para filtro (anteriormente categorías)
    let cuentasUnicas: string[] = [];
    let ubicaciones: string[] = [];
    
    // Totales
    let totalIngresos: number = 0;
    let totalGastos: number = 0;
    let saldo: number = 0;    // Estado para la edición
    let editingOperation: Operacion | null = null;
    let modalTypeToShow: 'income' | 'expense' | null = null;
    
    // Función para convertir fecha en formato "21-May-25" a timestamp
    function parseCustomDate(dateStr: string): number {
        try {
            if (dateStr.includes('-')) {
                // Formato dd-MMM-yy (ejemplo: 21-May-25, 9-Oct-24, 9-Sep-23)
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    const day = parseInt(parts[0]);
                    // Lista de meses en inglés para detectar el formato correcto
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const month = monthNames.indexOf(parts[1]);
                    if (month >= 0) {
                        let year = parseInt(parts[2]);
                        // Asumir que años de dos dígitos menores a 50 son del 2000 en adelante
                        if (year < 100) {
                            year = year < 50 ? 2000 + year : 1900 + year;
                        }
                        // Crear fecha y validar que sea correcta
                        const dateObj = new Date(year, month, day);
                        if (!isNaN(dateObj.getTime())) {
                            return dateObj.getTime();
                        }
                    }
                }
            } else if (dateStr.includes('/')) {
                // Formato dd/mm/yyyy
                const [day, month, year] = dateStr.split('/');
                return new Date(parseInt(year), parseInt(month) - 1, parseInt(day)).getTime();
            }
            
            // Si no es ninguno de los formatos anteriores, intentar con Date
            return new Date(dateStr).getTime();
        } catch (error) {
            console.error('Error al parsear fecha:', error, dateStr);
            return 0;
        }
    }
    
    // Formatear fecha para mostrarla
    function formatearFecha(fechaStr: string): string {
        try {
            // Si la fecha ya está en el formato correcto (21-May-25, 9-Oct-24), simplemente devolverla
            if (fechaStr.includes('-') && fechaStr.split('-').length === 3) {
                const [day, month, year] = fechaStr.split('-');
                // Verificar si es un formato válido con mes en texto
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                if (monthNames.includes(month)) {
                    return `${day}-${month}-${year}`;
                }
            }
            
            let fecha;
            
            // Manejar diferentes formatos de fecha
            if (fechaStr.includes('/')) {
                // Formato dd/mm/yyyy
                const [day, month, year] = fechaStr.split('/');
                fecha = new Date(`${month}/${day}/${year}`);
            } else {
                // Formato ISO o similar
                fecha = new Date(fechaStr);
            }
            
            // Verificar si la fecha es válida
            if (isNaN(fecha.getTime())) {
                console.error('Fecha inválida en formatearFecha:', fechaStr);
                return 'Fecha inválida';
            }
            
            // Obtener componentes de la fecha
            const day = fecha.getDate().toString();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = monthNames[fecha.getMonth()];
            const year = fecha.getFullYear().toString().substring(2); // Solo los últimos 2 dígitos
            
            return `${day}-${month}-${year}`;
        } catch (error) {
            console.error('Error al formatear fecha:', error, fechaStr);
            return 'Fecha inválida';
        }
    }
      // Función para filtrar operaciones (optimizada)
    function filtrarOperaciones(): void {
        // Preparar las variables de búsqueda fuera del bucle para evitar recrearlas por cada operación
        const busqueda = filtroBusqueda ? filtroBusqueda.toLowerCase() : '';
        const fechaDesde = filtroFechaDesde ? new Date(filtroFechaDesde) : null;
        
        // Crear fecha hasta con el final del día seleccionado
        let fechaHasta = null;
        if (filtroFechaHasta) {
            fechaHasta = new Date(filtroFechaHasta);
            fechaHasta.setHours(23, 59, 59, 999); // Fin del día
        }
        
        // Aplicar filtros de manera más eficiente
        operacionesFiltradas = operaciones.filter(op => {
            // Verificar los filtros más rápidos primero para mejorar rendimiento
            // (principio de corto-circuito)
            
            // Filtro por tipo
            if (filtroTipo !== 'todos' && op.type !== filtroTipo) return false;
            
            // Filtro por cuenta 
            if (filtroCuenta !== 'todas' && op.cuenta !== filtroCuenta) return false;
            
            // Filtro por ubicación
            if (filtroUbicacion !== 'todas' && op.location !== filtroUbicacion) return false;
            
            // Filtros más costosos al final
            
            // Filtro por fecha desde
            if (fechaDesde && new Date(op.date) < fechaDesde) return false;
            
            // Filtro por fecha hasta
            if (fechaHasta && new Date(op.date) > fechaHasta) return false;
            
            // Filtro por texto de búsqueda (el más costoso)
            if (busqueda) {
                const descripcionMatches = op.description?.toLowerCase().includes(busqueda);
                const notasMatches = op.notes?.toLowerCase().includes(busqueda);
                const facturaMatches = op.invoice?.toLowerCase().includes(busqueda);
                if (!descripcionMatches && !notasMatches && !facturaMatches) return false;
            }
            
            return true;
        });        // Aplicar ordenación        operacionesFiltradas.sort((a, b) => {
            if (ordenPor === 'fecha') {
                const fechaA = parseCustomDate(a.date);
                const fechaB = parseCustomDate(b.date);
                
                // Si alguna fecha es inválida (0), colocarla al final
                if (fechaA === 0 && fechaB !== 0) return ordenDireccion === 'asc' ? 1 : -1;
                if (fechaB === 0 && fechaA !== 0) return ordenDireccion === 'asc' ? -1 : 1;
                if (fechaA === 0 && fechaB === 0) return 0;
                
                return ordenDireccion === 'asc' ? fechaA - fechaB : fechaB - fechaA;
            } else if (ordenPor === 'monto') {
                return ordenDireccion === 'asc' ? a.amount - b.amount : b.amount - a.amount;
            } else if (ordenPor === 'descripcion') {
                return ordenDireccion === 'asc' 
                    ? a.description.localeCompare(b.description) 
                    : b.description.localeCompare(a.description);
            }
            return 0;
        });
        
        // Calcular totales
        totalIngresos = operacionesFiltradas
            .filter(op => op.type === 'ingreso')
            .reduce((sum, op) => sum + op.amount, 0);
            
        totalGastos = operacionesFiltradas
            .filter(op => op.type === 'egreso')
            .reduce((sum, op) => sum + op.amount, 0);
            
        saldo = totalIngresos - totalGastos;
    }
    
    // Procesar datos del store de transacciones
    function procesarTransacciones(transaccionesDelStore: Transaction[]): void {
        // Verificar que los datos sean válidos para evitar errores
        if (!Array.isArray(transaccionesDelStore)) {
            console.error('Datos recibidos no son un array:', transaccionesDelStore);
            return;
        }
        
        // Crear una copia para evitar modificar el store directamente
        // y asegurar que estén ordenadas por fecha descendente (más reciente primero)
        operaciones = [...transaccionesDelStore].sort((a, b) => {
            try {
                const dateA = parseCustomDate(a.date);
                const dateB = parseCustomDate(b.date);
                
                // Verificar validez de las fechas y hacer debug
                if (isNaN(dateA) || dateA === 0) {
                    console.error('Fecha A inválida en ordenamiento inicial:', a.date, dateA);
                }
                if (isNaN(dateB) || dateB === 0) {
                    console.error('Fecha B inválida en ordenamiento inicial:', b.date, dateB);
                }
                
                // Mostrar algunos ejemplos de fechas (solo para debugging)
                if (Math.random() < 0.01) { // Mostrar aproximadamente 1% de las fechas para no sobrecargar la consola
                    console.log(`Fecha ordenada: ${a.date} -> ${new Date(dateA).toISOString()}`);
                }
                
                return dateB - dateA; // Orden descendente por fecha
            } catch (error) {
                console.error('Error al ordenar fechas:', error, { a: a.date, b: b.date });
                return 0;
            }
        });

        // Extraer cuentas y ubicaciones únicas para los filtros
        const cuentasSet = new Set<string>();
        const ubicacionesSet = new Set<string>();
        
        operaciones.forEach(op => {
            if (op.cuenta) cuentasSet.add(op.cuenta);
            if (op.location) ubicacionesSet.add(op.location);
        });
        
        cuentasUnicas = Array.from(cuentasSet).sort();
        ubicaciones = Array.from(ubicacionesSet).sort();
        
        // Aplicar filtros
        filtrarOperaciones();
        
        if (!datosCargadosInicialmente) {
            datosCargadosInicialmente = true;
        }
    }
    
    // Cambiar ordenación
    function cambiarOrden(campo: string): void {
        if (ordenPor === campo) {
            // Si ya estamos ordenando por este campo, cambiar dirección
            ordenDireccion = ordenDireccion === 'asc' ? 'desc' : 'asc';
        } else {
            // Nuevo campo de ordenación
            ordenPor = campo;
            // Para fecha, ordenar descendente por defecto, para otros ascendente
            ordenDireccion = campo === 'fecha' ? 'desc' : 'asc';
        }
        
        filtrarOperaciones();
    }

  // En Operaciones.svelte
  function handleRowDoubleClick(operation: Operacion): void {
      editingOperation = operation;
      modalTypeToShow = operation.type === 'ingreso' ? 'income' : 'expense';
  }
  

    function handleModalClose(): void {
        modalTypeToShow = null;
        editingOperation = null; // Limpiar la operación en edición al cerrar
    }
      // Crear una combinación de todos los filtros para optimizar la reactividad
    $: filtrosCombinados = { 
        tipo: filtroTipo, 
        cuenta: filtroCuenta, 
        ubicacion: filtroUbicacion, 
        busqueda: filtroBusqueda, 
        fechaDesde: filtroFechaDesde, 
        fechaHasta: filtroFechaHasta,
        orden: ordenPor,
        direccion: ordenDireccion
    };
    
    // Usar debounce para la búsqueda por texto para evitar procesamiento excesivo
    let debounceTimer: number | null = null;
    $: {
        if (datosCargadosInicialmente) {
            // Cancelar temporizador anterior si existe
            if (debounceTimer !== null) {
                clearTimeout(debounceTimer);
            }
            
            // Si es un cambio en la búsqueda por texto, usar debounce
            if (filtroBusqueda !== undefined) {
                debounceTimer = setTimeout(() => {
                    filtrarOperaciones();
                    debounceTimer = null;
                }, 300) as unknown as number;
            } else {
                // Para otros filtros, aplicar inmediatamente
                filtrarOperaciones();
            }
        }
    }
      // Variables para scroll infinito
    let tablaContainer: HTMLDivElement;
    let scrollLoadingThreshold = 200; // píxeles desde el fondo para cargar más
    let loadingMoreData = false; // Estado local para evitar múltiples cargas
      // Manejar el evento de scroll para cargar más datos cuando se acerca al final
    function handleScroll() {
        if ($isLoadingMore || !$hasMoreData || loadingMoreData) return;
        
        const { scrollTop, scrollHeight, clientHeight } = tablaContainer;
        const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
        
        if (distanceFromBottom < scrollLoadingThreshold) {
            loadingMoreData = true;
            loadMoreTransactions().then(() => {
                loadingMoreData = false;
            }).catch(error => {
                console.error('Error al cargar más transacciones:', error);
                loadingMoreData = false;
            });
        }
    }
    
    // Optimizar la renderización evitando múltiples actualizaciones durante el scrolling
    let scrollTimer: number | null = null;
    function optimizedHandleScroll() {
        if (scrollTimer !== null) {
            clearTimeout(scrollTimer);
        }
        scrollTimer = setTimeout(() => {
            handleScroll();
            scrollTimer = null;
        }, 100) as unknown as number;
    }
    
    // Suscribirse al store de transacciones y cargar datos iniciales
    onMount(() => {
        // Cargar la primera página de datos
        loadFirstPage();
        
        // Suscribirse a las actualizaciones del store
        const unsubscribe = transactions.subscribe(procesarTransacciones);
        
        return () => {
            // Limpiar temporizador y desuscribirse al desmontar
            if (scrollTimer !== null) {
                clearTimeout(scrollTimer);
            }
            unsubscribe();
        };
    });
</script>

{#if modalTypeToShow === 'income'}
    <IncomeModal 
        show={true} 
        initialData={editingOperation} 
        on:close={handleModalClose} 
    />
{:else if modalTypeToShow === 'expense'}
    <ExpenseModal 
        show={true} 
        initialData={editingOperation} 
        on:close={handleModalClose} 
    />
{/if}

<div class="operaciones-container">
    <div class="header-container">
        <h2>Operaciones</h2>
        <ActionButton 
            text="Actualizar datos" 
            icon="↻"
            action={forceRefreshData}
            loading={$refreshing}
            variant="secondary"
        />
    </div>
    
    <!-- Panel de filtros -->
    <div class="filtros-panel">
        <div class="filtro-grupo">
            <label for="filtroTipo">Tipo:</label>
            <select id="filtroTipo" bind:value={filtroTipo}>
                <option value="todos">Todos</option>
                <option value="ingreso">Ingresos</option>
                <option value="egreso">Egresos</option>
            </select>
        </div>
        
        <div class="filtro-grupo">
            <label for="filtroCuenta">Cuenta:</label>
            <select id="filtroCuenta" bind:value={filtroCuenta}>
                <option value="todas">Todas</option>
                {#each cuentasUnicas as cuenta}
                    <option value={cuenta}>{cuenta.charAt(0).toUpperCase() + cuenta.slice(1)}</option>
                {/each}
            </select>
        </div>
        
        <div class="filtro-grupo">
            <label for="filtroUbicacion">Ubicación:</label>
            <select id="filtroUbicacion" bind:value={filtroUbicacion}>
                <option value="todas">Todas</option>
                {#each ubicaciones as ubicacion}
                    <option value={ubicacion}>{ubicacion}</option>
                {/each}
            </select>
        </div>
        
        <div class="filtro-fecha">
            <div class="filtro-grupo">
                <label for="filtroFechaDesde">Desde:</label>
                <input 
                    type="date" 
                    id="filtroFechaDesde" 
                    bind:value={filtroFechaDesde}
                >
            </div>
            
            <div class="filtro-grupo">
                <label for="filtroFechaHasta">Hasta:</label>
                <input 
                    type="date" 
                    id="filtroFechaHasta" 
                    bind:value={filtroFechaHasta}
                >
            </div>
        </div>
        
        <div class="filtro-busqueda">
            <input 
                type="text" 
                placeholder="Buscar..."
                bind:value={filtroBusqueda}
            >
        </div>
    </div>
    
    <!-- Resumen financiero -->
    <div class="resumen-financiero">
        <div class="resumen-item ingresos">
            <span>Ingresos</span>
            <strong>{formatCurrency(totalIngresos)}</strong>
        </div>
        
        <div class="resumen-item gastos">
            <span>Gastos</span>
            <strong>{formatCurrency(totalGastos)}</strong>
        </div>
        
        <div class="resumen-item saldo" class:negativo={saldo < 0}>
            <span>Saldo</span>
            <strong>{formatCurrency(saldo)}</strong>
        </div>
    </div>
      <!-- Tabla de operaciones con scroll infinito -->
    {#if !$isInitialDataLoaded && operacionesFiltradas.length === 0}
        <div class="cargando">Cargando datos...</div>
    {:else if $isInitialDataLoaded && operacionesFiltradas.length === 0}
        <div class="sin-datos">
            No se encontraron operaciones con los filtros seleccionados.
        </div>
    {:else}        <div 
            class="tabla-operaciones" 
            bind:this={tablaContainer} 
            on:scroll={optimizedHandleScroll}
        >
            <table>
                <thead>
                    <tr>
                        <th on:click={() => cambiarOrden('fecha')} class:activo={ordenPor === 'fecha'}>
                            Fecha {ordenPor === 'fecha' && (ordenDireccion === 'asc' ? '▲' : '▼')}
                        </th>
                        <th on:click={() => cambiarOrden('descripcion')} class:activo={ordenPor === 'descripcion'}>
                            Descripción {ordenPor === 'descripcion' && (ordenDireccion === 'asc' ? '▲' : '▼')}
                        </th>
                        <th>Cuenta</th>
                        <th>Ubicación</th>
                        <th on:click={() => cambiarOrden('monto')} class:activo={ordenPor === 'monto'}>
                            Monto {ordenPor === 'monto' && (ordenDireccion === 'asc' ? '▲' : '▼')}
                        </th>
                    </tr>
                </thead>
                <tbody>
                    {#each operacionesFiltradas as op}
                        <tr 
                            class:ingreso={op.type === 'ingreso'} 
                            class:egreso={op.type === 'egreso'} 
                            on:click={() => handleRowDoubleClick(op)} 
                            style="cursor: pointer;">
                            <td>{formatearFecha(op.date)}</td>
                            <td class="descripcion-celda">
                                <div class="descripcion-contenido">
                                    <span>{op.description}</span>
                                    {#if op.notes}
                                        <div class="notas">{op.notes}</div>
                                    {/if}
                                    {#if op.invoice}
                                        <div class="factura">Ref: {op.invoice}</div>
                                    {/if}
                                </div>
                            </td>
                            <td>
                                {op.type === 'ingreso' ? 'Ingreso' : op.cuenta ? op.cuenta.charAt(0).toUpperCase() + op.cuenta.slice(1) : '-'}
                            </td>
                            <td>{op.location || '-'}</td>
                            <td class="monto-celda">
                                <span class={op.type}>
                                     {op.type === 'ingreso' ? '+' : '-'}{formatCurrency(op.amount, '')}
                                </span>
                                {#if op.paymentMethod}
                                    <div class="metodo-pago">{op.paymentMethod}</div>
                                {/if}
                            </td>
                        </tr>
                    {/each}
                </tbody>
            </table>
            
            {#if $isLoadingMore}
                <div class="cargando-mas">
                    <div class="spinner"></div>
                    <span>Cargando más transacciones...</span>
                </div>
            {/if}
            
            {#if !$hasMoreData && operacionesFiltradas.length > 0}
                <div class="sin-mas-datos">
                    No hay más transacciones para cargar
                </div>
            {/if}
        </div>
    {/if}
</div>

<style>
    .operaciones-container {
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 1.5rem;
        margin-bottom: 2rem;
    }
      .header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
    }
    
    h2 {
        margin-top: 0;
        margin-bottom: 0;
        color: #333;
        font-size: 1.8rem;
    }
    
    .filtros-panel {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1.5rem;
        background-color: #f9f9f9;
        padding: 1rem;
        border-radius: 8px;
    }
    
    .filtro-grupo {
        display: flex;
        flex-direction: column;
        min-width: 120px;
    }
    
    .filtro-grupo label {
        font-size: 0.85rem;
        margin-bottom: 0.3rem;
        color: #666;
    }
    
    .filtro-grupo select,
    .filtro-grupo input,
    .filtro-busqueda input {
        padding: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9rem;
    }
    
    .filtro-fecha {
        display: flex;
        gap: 0.5rem;
    }
    
    .filtro-busqueda {
        flex-grow: 1;
    }
    
    .filtro-busqueda input {
        width: 100%;
    }
    
    .resumen-financiero {
        display: flex;
        gap: 1.5rem;
        margin-bottom: 1.5rem;
        padding: 1rem;
        background-color: #f5f5f5;
        border-radius: 8px;
    }
    
    .resumen-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        min-width: 120px;
    }
    
    .resumen-item span {
        font-size: 0.9rem;
        color: #666;
    }
    
    .resumen-item strong {
        font-size: 1.3rem;
        margin-top: 0.3rem;
    }
    
    .ingresos {
        background-color: rgba(76, 175, 80, 0.1);
    }
    
    .ingresos strong {
        color: #4CAF50;
    }
    
    .gastos {
        background-color: rgba(244, 67, 54, 0.1);
    }
    
    .gastos strong {
        color: #F44336;
    }
    
    .saldo {
        background-color: rgba(33, 150, 243, 0.1);
    }
    
    .saldo strong {
        color: #2196F3;
    }
    
    .saldo.negativo strong {
        color: #F44336;
    }
    
    .tabla-operaciones {
        overflow-x: auto; /* Mantenemos el scroll horizontal si es necesario para la tabla */
        max-height: 700px; /* Define una altura máxima, ajusta este valor según tus necesidades */
        overflow-y: auto !important; /* Agrega scroll vertical cuando el contenido excede max-height */
        display: block; /* Asegurarse que el div es un bloque para que funcione el scrolling */
    }
    
    table {
        width: 100%;
        border-collapse: collapse;
    }
    
    th, td {
        padding: 0.8rem;
        text-align: left;
        border-bottom: 1px solid #eee;
    }
    
    th {
        background-color: #f5f5f5;
        font-weight: 600;
        color: #444;
        cursor: pointer;
        user-select: none;
    }
    
    th.activo {
        background-color: #e9e9e9;
    }
    
    tbody tr:hover {
        background-color: #f9f9f9;
    }
    
    .descripcion-celda {
        max-width: 300px;
    }
    
    .descripcion-contenido {
        display: flex;
        flex-direction: column;
    }
    
    .notas, .factura {
        font-size: 0.8rem;
        color: #777;
        margin-top: 0.3rem;
    }
    
    .factura {
        font-style: italic;
    }
    
    .monto-celda {
        font-weight: 500;
    }
    
    .metodo-pago {
        font-size: 0.8rem;
        color: #777;
        margin-top: 0.3rem;
    }
    
    .ingreso {
        border-left: 3px solid #4CAF50;
    }
    
    .egreso { /* Cambiado de gasto a egreso */
        border-left: 3px solid #F44336;
    }
    
    .ingreso .ingreso {
        color: #4CAF50;
    }
    /* Estilo para montos de egreso */
    .egreso .egreso, .egreso span[class*="egreso"] { /* Asegurar que el monto de egreso también se coloree */
        color: #F44336;
    }
    
    .cargando, .error, .sin-datos {
        padding: 2rem;
        text-align: center;
        background-color: #f9f9f9;
        border-radius: 8px;
        margin: 1rem 0;
    }
    
    /* Los estilos del botón se han movido al componente ActionButton.svelte */
    
    /* Estilos para carga infinita */
    .cargando-mas {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        background-color: #f5f5f5;
        margin-top: 0.5rem;
        border-radius: 4px;
    }
    
    .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid rgba(0, 0, 0, 0.1);
        border-top-color: #2196F3;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
    }
    
    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }
    
    .sin-mas-datos {
        text-align: center;
        padding: 1rem;
        color: #666;
        font-style: italic;
        background-color: #f9f9f9;
        margin-top: 0.5rem;
        border-radius: 4px;
    }
</style>
